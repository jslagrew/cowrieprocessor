"""Utilities to enrich Cowrie malware events with VirusTotal data.

This script scans one Cowrie JSON log file or a directory of such files and,
for any file download/upload events, queries VirusTotal for malware metadata.
Results are appended to a local `vt_data` file.

Run this as a standalone script; arguments are parsed at import time.
"""

import argparse
import datetime
import json
import logging
import os
import sys
from functools import lru_cache

import requests

from secrets_resolver import is_reference, resolve_secret

BASIC_WITH_TIME_FORMAT = '%(asctime)s:%(levelname)s:%(name)s:%(message)s'
logging_fhandler = logging.FileHandler("cowrie_malware_enrichment.log")
logging_fhandler.setFormatter(logging.Formatter(BASIC_WITH_TIME_FORMAT))
logging_fhandler.setLevel(logging.WARNING)
stdout_handler = logging.StreamHandler(stream=sys.stdout)
stdout_handler.setLevel(logging.DEBUG)
logging.root.addHandler(logging_fhandler)
logging.root.addHandler(stdout_handler)
logging.root.setLevel(logging.DEBUG)

parser = argparse.ArgumentParser(description='DShield Honeypot Cowrie Data Identifiers')
parser.add_argument(
    '--filepath',
    dest='filepath',
    type=str,
    help='Path of cowrie json log file',
    default='/srv/cowrie/var/log/cowrie/cowrie.json',
)
parser.add_argument(
    '--directory',
    dest='directory',
    type=str,
    help='Path of cowrie json log files',
    default=None,
)
parser.add_argument('--vtapi', dest='vtapi', type=str, help='VirusTotal API key (required for VT data lookup)')
parser.add_argument(
    '--timespan',
    dest='timespan',
    type=int,
    help=('Number of seconds in the past to look for data ' '(60 would be any data logged in the last minute)'),
    default=None,
)
args = parser.parse_args()

input_filepath = args.filepath
directory = args.directory
if directory is not None:
    if directory.endswith("/"):
        directory = directory[:-1]
vt_api = args.vtapi or os.getenv('VT_API_KEY')
try:
    if is_reference(vt_api):
        vt_api = resolve_secret(vt_api)
except Exception:
    pass
timespan = args.timespan

vt_session = requests.session()


def find_cowrie_malware(log_filepath, max_age_seconds=None):
    """Find file transfer events in a Cowrie log and enrich via VT.

    Args:
        log_filepath: Path to a single Cowrie JSON log file.
        max_age_seconds: Optional number of seconds; only events newer than
            now - max_age_seconds are processed. If provided, must be ``int``.

    Returns:
        None. Side effects: writes VT lookups to ``vt_data``.
    """
    existing_hashes_logged = find_exising_logs()
    if max_age_seconds is not None:
        if not isinstance(max_age_seconds, int):
            raise TypeError("Timespan supplied for comparison must be an integer!")

    cowrie_data = []

    logging.debug("Processing file %s", log_filepath)
    with open(log_filepath, "r", encoding="utf-8") as file:
        for each_line in file:
            json_data = json.loads(each_line)
            cowrie_data.append(json_data)

    for each_log in cowrie_data:
        if each_log["eventid"] in (
            "cowrie.session.file_download",
            "cowrie.session.file_upload",
        ):
            timestamp = datetime.datetime.strptime(each_log['timestamp'], "%Y-%m-%dT%H:%M:%S.%fZ")
            if max_age_seconds is None or max_age_seconds > (datetime.datetime.now() - timestamp).total_seconds():
                logging.debug(
                    "%s found in session %s at %s: hash %s",
                    each_log['eventid'],
                    each_log['session'],
                    each_log['timestamp'],
                    each_log['shasum'],
                )
                if each_log['shasum'] not in existing_hashes_logged:
                    vt_lookup(vt_api, each_log['shasum'])


def find_exising_logs(vt_log_path="vt_data"):
    """Return the set of hashes already present in a VT log file.

    Args:
        vt_log_path: Path to the file that stores prior VT lookup results.

    Returns:
        A ``set`` of SHA-256 strings already recorded.
    """
    hashes = set()
    if os.path.exists(vt_log_path):
        with open(vt_log_path, "r", encoding="utf-8") as file:
            for each_line in file:
                try:
                    json_data = json.loads(each_line)
                    if "hash" in json_data:
                        hashes.add(json_data["hash"])
                except Exception:
                    logging.error(
                        "Issue reading json from %s. Maybe missing data: %r",
                        vt_log_path,
                        each_line,
                    )
    return hashes


@lru_cache
def vt_lookup(
    vt_api_key,
    file_hash="a8460f446be540410004b1a8db4083773fa46f7fe76fa84219c93daa1669f8f2",
):
    """Query VirusTotal for a file hash and append results to disk.

    Args:
        vt_api_key: VirusTotal API key string.
        file_hash: SHA-256 hash of the file to look up.

    Returns:
        None. Side effects: appends a JSON line to ``vt_data``.
    """
    logging.info("Starting VT lookup for %s", file_hash)
    vt_data = {}
    vt_data["hash"] = file_hash
    vt_session.headers = {'X-Apikey': vt_api_key}
    url = "https://www.virustotal.com/api/v3/files/" + file_hash
    response = vt_session.get(url)
    json_response = json.loads(response.text)
    logging.debug(response.text)
    if "error" in json_response:
        for key, value in json_response["error"].items():
            logging.error("VT Error for hash '%s': %s", file_hash, value)
    elif "data" in json_response:
        if "attributes" in json_response["data"]:
            attrs = json_response["data"]["attributes"]
            if "last_analysis_stats" in attrs:
                for key, value in attrs["last_analysis_stats"].items():
                    vt_data[key] = value
                if "last_analysis_date" in attrs:
                    vt_data["last_analysis_date"] = attrs["last_analysis_date"]
                if "trid" in attrs:
                    vt_data["filetype"] = attrs["trid"][0]["file_type"]
                if "type_tag" in attrs:
                    vt_data["typetag"] = attrs["type_tag"]
                if "type_description" in attrs:
                    vt_data["description"] = attrs["type_description"]
                if "meaningful_name" in attrs:
                    vt_data["filename"] = attrs["meaningful_name"]
                if "popular_threat_classification" in attrs:
                    vt_data["classification"] = attrs["popular_threat_classification"]["suggested_threat_label"]

        with open("vt_data", "a", encoding="utf-8") as filehandle:
            filehandle.write(json.dumps(vt_data) + "\n")


if directory is not None:
    for each_file in os.listdir(directory):
        if "cowrie.json" in each_file:
            find_cowrie_malware(f"{directory}/{each_file}", timespan)
else:
    find_cowrie_malware(input_filepath, timespan)
vt_session.close()
